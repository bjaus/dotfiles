#!/usr/bin/env bash

# Git pre-commit hook to format Go files
# This ensures all Go files are properly formatted before committing

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if we have any Go files staged
if ! git diff --cached --name-only | grep -q '\.go$'; then
  exit 0
fi

echo "üîç Checking Go file formatting..."

# Check for required tools
MISSING_TOOLS=()
if ! command -v goimports &> /dev/null; then
  MISSING_TOOLS+=("goimports")
fi
if ! command -v gofumpt &> /dev/null; then
  MISSING_TOOLS+=("gofumpt")
fi

# If tools are missing, try to install them
if [ ${#MISSING_TOOLS[@]} -gt 0 ]; then
  echo -e "${YELLOW}Missing tools: ${MISSING_TOOLS[*]}${NC}"
  echo "Installing missing Go formatters..."
  
  if [[ " ${MISSING_TOOLS[@]} " =~ " goimports " ]]; then
    go install golang.org/x/tools/cmd/goimports@latest 2>/dev/null || {
      echo -e "${RED}Failed to install goimports${NC}"
      echo "Run: go install golang.org/x/tools/cmd/goimports@latest"
      exit 1
    }
  fi
  
  if [[ " ${MISSING_TOOLS[@]} " =~ " gofumpt " ]]; then
    go install mvdan.cc/gofumpt@latest 2>/dev/null || {
      echo -e "${RED}Failed to install gofumpt${NC}"
      echo "Run: go install mvdan.cc/gofumpt@latest"
      exit 1
    }
  fi
fi

# Get all staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

if [ -z "$STAGED_GO_FILES" ]; then
  exit 0
fi

# Function to check if file is generated
is_generated_file() {
  local file="$1"
  # Check if file contains "Code generated" or "DO NOT EDIT" in first 5 lines
  if head -n 5 "$file" 2>/dev/null | grep -q -E "(Code generated|DO NOT EDIT|Autogenerated|autogenerated|AUTOGENERATED|Generated by)"; then
    return 0
  fi
  # Also check for common generated file patterns
  if [[ "$file" =~ \.(pb|twirp)\.go$ ]] || [[ "$file" =~ \.gen\.go$ ]] || [[ "$file" =~ _gen\.go$ ]]; then
    return 0
  fi
  return 1
}

# Format each file
FORMATTED_FILES=()
FAILED_FILES=()
SKIPPED_FILES=()

for FILE in $STAGED_GO_FILES; do
  if [ -f "$FILE" ]; then
    # Skip generated files
    if is_generated_file "$FILE"; then
      SKIPPED_FILES+=("$FILE")
      echo -e "${YELLOW}‚äò Skipping generated file: $FILE${NC}"
      continue
    fi
    # Run goimports first (organizes imports)
    if goimports -w "$FILE" 2>/dev/null; then
      # Then run gofumpt (stricter formatting)
      if gofumpt -w "$FILE" 2>/dev/null; then
        # Check if the file was modified
        if ! git diff --quiet "$FILE"; then
          FORMATTED_FILES+=("$FILE")
        fi
      else
        FAILED_FILES+=("$FILE")
        echo -e "${RED}‚úó Failed to format: $FILE${NC}"
      fi
    else
      FAILED_FILES+=("$FILE")
      echo -e "${RED}‚úó Failed to organize imports: $FILE${NC}"
    fi
  fi
done

# If files were formatted, add them back to staging
if [ ${#FORMATTED_FILES[@]} -gt 0 ]; then
  echo -e "${GREEN}‚úì Formatted ${#FORMATTED_FILES[@]} Go file(s):${NC}"
  for FILE in "${FORMATTED_FILES[@]}"; do
    echo "  ‚Ä¢ $FILE"
    git add "$FILE"
  done
  echo ""
  echo -e "${YELLOW}Files have been formatted and re-staged.${NC}"
  echo -e "${YELLOW}Please review the changes before committing.${NC}"
fi

# If any files failed to format, block the commit
if [ ${#FAILED_FILES[@]} -gt 0 ]; then
  echo -e "${RED}Some files could not be formatted. Please fix them manually.${NC}"
  exit 1
fi

# Run go vet on affected packages (not individual files)
echo "üîç Running go vet on affected packages..."

# Get unique package directories from staged files
PACKAGE_DIRS=()
for FILE in $STAGED_GO_FILES; do
  if [ -f "$FILE" ]; then
    # Skip generated files for go vet
    if is_generated_file "$FILE"; then
      continue
    fi
    DIR=$(dirname "$FILE")
    # Add to array if not already present
    if [[ ! " ${PACKAGE_DIRS[@]} " =~ " ${DIR} " ]]; then
      PACKAGE_DIRS+=("$DIR")
    fi
  fi
done

# Run go vet on each package directory (this gives proper context)
VET_FAILED=false
for DIR in "${PACKAGE_DIRS[@]}"; do
  echo "  Checking package: $DIR"
  # Run go vet on just the current package (not recursive)
  # This ensures all type definitions in the same package are available
  if ! (cd "$DIR" && go vet . 2>/dev/null); then
    VET_OUTPUT=$(cd "$DIR" && go vet . 2>&1 || true)
    
    # Check if the error is about our staged files
    STAGED_IN_DIR=false
    for FILE in $STAGED_GO_FILES; do
      if [[ "$FILE" == "$DIR"* ]] && ! is_generated_file "$FILE"; then
        STAGED_IN_DIR=true
        break
      fi
    done
    
    if [ "$STAGED_IN_DIR" = true ]; then
      # Check if it's a real error or just missing dependencies from other packages
      if echo "$VET_OUTPUT" | grep -q -E "(undefined:|not used|undeclared name)"; then
        echo -e "  ${YELLOW}‚ö† Type/import issues in $DIR (may be resolved by full build)${NC}"
        # Don't fail for type resolution issues - they might be resolved when full project builds
      else
        echo -e "  ${RED}‚úó go vet failed in package: $DIR${NC}"
        echo "$VET_OUTPUT" | sed 's/^/    /'
        VET_FAILED=true
      fi
    fi
  else
    echo -e "  ${GREEN}‚úì Package OK: $DIR${NC}"
  fi
done

if [ "$VET_FAILED" = true ]; then
  echo ""
  echo -e "${RED}‚ùå go vet found real issues that need to be fixed.${NC}"
  echo -e "${YELLOW}Fix the issues above before committing.${NC}"
  exit 1
fi

# Summary
echo ""
if [ ${#SKIPPED_FILES[@]} -gt 0 ]; then
  echo -e "${YELLOW}Skipped ${#SKIPPED_FILES[@]} generated file(s)${NC}"
fi
echo -e "${GREEN}‚úì All non-generated Go files properly formatted and vetted!${NC}"
exit 0